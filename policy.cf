bundle agent scc
{
  methods:
    "scc:packages";
    "scc:schedule";
    "scc:inventory";
}
bundle agent __main__
{
      methods: "scc";
}

body file control
{
  namespace => "scc";
}

bundle agent packages
{
  packages:
      "spawarscc"
        policy => "present",
        action => default:policy( "warn" ),
        classes => default:results( "bundle", "package_spawarscc" );

  reports:
    package_spawarscc_not_kept::
      "$(with)"
        with => concat( "spawarscc is not installed, please retreive and",
                        " install the version appropriate for your platform from",
                        " https://public.cyber.mil/stigs/scap/" );

    package_spawarscc_kept.(scc:DEBUG_packages)::
      "spawarscc is installed";

}

bundle agent schedule
{
  vars:
      "hours" slist => expandrange( "[1-23]", 1 );

      "hour_selected"
        string => hash_to_int( 1, 23, "CHANGEME" ),
        if => not( isvariable( "scc:schedule.hour_selected" ) );

      "minute_selected"
        string => hash_to_int( 1, 59, "CHANGEME" ),
        if => not( isvariable( "scc:schedule.minute_selected" ) );

      "time_selected"
        string => concat( format( "%02d", "$(hour_selected)" ),
                          ":",
                          format( "%02d", "$(minute_selected)" ) ),
        meta =>  { "inventory", "attribute_name=SCC Scheduled Scan Time" };

      "output_dir" string => "/tmp/SCC-RESULT";
      "command" string => "/opt/scc/cscc --userDir $(output_dir)";

      "cron_entry" string => "$(minute_selected) $(hour_selected) * * * root $(command) >/dev/null 2>&1$(const.n)";

  files:
      "$(output_dir)/." create => "true";
      "/etc/cron.d/security-scan"
        content => concat( "# CFEngine Managed$(const.n)",
                           "$(cron_entry)" ),
        perms => default:mog( "644", "root", "root" ); # Wth, mode 0700!?

      # [root@hub scc]# cf-agent -KI
      # info: Created directory '/tmp/SCC-RESULT/.', mode 0700
      # info: Updated file '/etc/cron.hourly/security-scan' with content '# CFEngine Managed
      # 0 15 * * * /opt/scc/cscc --userDir /tmp/SCC-RESULT >/dev/null 2>&1'
      # R: Newest: $(newest_file)
      # error: A method attempted to use a bundle 'inventory_read' that was apparently not defined
      # error: Fatal CFEngine error: Aborting due to missing bundle 'inventory_read'

}

bundle agent inventory
{
  methods:
      "inventory_parse";
      "inventory_report";
}
bundle agent inventory_parse
{
  vars:
      "xccdf_files" slist => findfiles( "$(scc:schedule.output_dir)/**/*XCCDF-Results*.xml" );
      "xccdf_file_mtime[$(xccdf_files)]"
        string => filestat( $(xccdf_files), "mtime" );

      "statefile" string => "$(sys.statedir)/scc-scan-result-inventory.txt";

      # The file with the largest mtime is the newest
      "newest_time" string => max( getvalues( "xccdf_file_mtime" ), int );
      "newest_file" string => "$(xccdf_files)", if => strcmp( "$(xccdf_file_mtime[$(xccdf_files)])", "$(newest_time)" );

      "filename_extract"
        data => data_regextract( ".*SCC-(?<scc_version>\d+\.\d+)_(?<scan_YYYY>\d+)-(?<scan_MM>\d+)-(?<scan_DD>\d+)_(?<scan_hh>\d\d)(?<scan_mm>\d\d)(?<scan_ss>\d\d)_XCCDF-Results_(?<scan_ruleset>.*)\.xml",
                                 basename( "$(newest_file)" ) );
      # {
      #   "0": "HUB_SCC-5.9_2024-04-11_172103_XCCDF-Results_RHEL_8_STIG-1.12.8.xml",
      #   "scan_DD": "11",
      #   "scan_MM": "04",
      #   "scan_YYYY": "2024",
      #   "scan_hh": "17",
      #   "scan_mm": "21",
      #   "scan_ruleset": "RHEL_8_STIG-1.12.8",
      #   "scan_ss": "03",
      #   "scc_version": "5.9"
      # }
      "inventory_ruleset"
        string => "$(filename_extract[scan_ruleset])",
        meta => { "inventory", "attribute_name=SCC Ruleset" };

      "inventory_report_date"
        string => "$(filename_extract[scan_YYYY])-$(filename_extract[scan_MM])-$(filename_extract[scan_DD])",
        meta => { "inventory", "attribute_name=SCC Report Date" };

      "inventory_report_scc_version"
        string => "$(filename_extract[scc_version])",
        meta => { "inventory", "attribute_name=SCC Report Version" };

  commands:
      "/var/cfengine/bin/cfengine-selected-python $(this.promise_dirname)/tools/parseXML.py $(newest_file) --parse-findings > $(statefile)"
        if => and(
                   isvariable( newest_file ) ),
        contain => default:in_shell;
                   #or( isnewerthan( "$(newest_file)", "$(statefile)" ),
        #           not( fileexists( "$(statefile)" )) ),

  reports:
      "$(xccdf_files)";
      "Newest: $(newest_file)";
}

bundle agent inventory_report
{
  vars:
      "report_dat" string => "$(scc:inventory_parse.statefile)";

      # The Short Names are unique in a report, so we can parse with data_readstringarray having the result indexed by short name.
      "d_report_dat"
        data => data_readstringarray( "$(report_dat)",
                                      "",
                                      "\s+",
                                      "inf",
                                      "inf"),
        if => fileexists( "$(report_dat)" );

      "i" slist => getindices( d_report_dat );

      "results" slist => { "fail", "notapplicable", "notchecked", "pass" };

      "$(results)[$(i)]"
        string => "$(i)",
        meta => { "inventory", "attribute_name=SCC $(results)" },
        if => strcmp( "$(results)", "$(d_report_dat[$(i)])" );

      "url_$(results)[$(i)]"
        string => "https://ato-pathways.com/search?q=$(i)&ifl=true",
        meta => { "inventory", "attribute_name=SCC $(results) URLs" },
        if => strcmp( "$(results)", "$(d_report_dat[$(i)])" );

}
