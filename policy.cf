bundle agent scc
{
  methods:
    "scc:packages";
    "scc:schedule";
    "scc:inventory";
}
bundle agent __main__
{
      methods: "scc";
}

body file control
{
  namespace => "scc";
}

bundle agent packages
{
  packages:
      "spawarscc"
        policy => "present",
        action => default:policy( "warn" ),
        classes => default:results( "bundle", "package_spawarscc" );

  reports:
    package_spawarscc_notkept::
      "$(with)"
        with => concat( "spawarscc is not installed, please retreive and",
                        " install the version appropriate for your platform from",
                        " https://public.cyber.mil/stigs/scap/" );

    package_spawarscc_kept.(scc:DEBUG_packages)::
      "spawarscc is installed";

}

bundle agent schedule
{
  vars:
      "hours" slist => expandrange( "[1-23]", 1 );

      "hour_selected"
        string => hash_to_int( 1, 23, "CHANGEME" ),
        meta =>  { "inventory", "attribute_name=SCC Scheduled Hour" },
        if => not( isvariable( "scc:schedule.hour_selected" ) );

      "output_dir" string => "/tmp/SCC-RESULT";
      "command" string => "/opt/scc/cscc --userDir $(output_dir)";

      "cron_entry" string => "0 $(hour_selected) * * * root $(command) >/dev/null 2>&1";

  files:
      "$(output_dir)/." create => "true";
      "/etc/cron.d/security-scan"
        content => concat( "# CFEngine Managed$(const.n)",
                           "$(cron_entry)" ),
        perms => default:mog( "644", "root", "root" ); # Wth, mode 0700!?

      # [root@hub scc]# cf-agent -KI
      # info: Created directory '/tmp/SCC-RESULT/.', mode 0700
      # info: Updated file '/etc/cron.hourly/security-scan' with content '# CFEngine Managed
      # 0 15 * * * /opt/scc/cscc --userDir /tmp/SCC-RESULT >/dev/null 2>&1'
      # R: Newest: $(newest_file)
      # error: A method attempted to use a bundle 'inventory_read' that was apparently not defined
      # error: Fatal CFEngine error: Aborting due to missing bundle 'inventory_read'

}

bundle agent inventory
{
  methods:
      "inventory_parse";
      "inventory_report";
}
bundle agent inventory_parse
{
  vars:
      "xccdf_files" slist => findfiles( "$(scc:schedule.output_dir)/**/*XCCDF-Results*.xml" );
      "xccdf_file_mtime[$(xccdf_files)]"
        string => filestat( $(xccdf_files), "mtime" );

      "statefile" string => "$(sys.statedir)/scc-scan-result-inventory.txt";

      # The file with the largest mtime is the newest
      "newest_time" string => max( getvalues( "xccdf_file_mtime" ), int );
      "newest_file" string => "$(xccdf_files)", if => strcmp( "$(xccdf_file_mtime[$(xccdf_files)])", "$(newest_time)" );

  commands:
      "/var/cfengine/bin/cfengine-selected-python $(this.promise_dirname)/tools/parseXML.py $(newest_file) --parse-findings > $(statefile)"
        if => and(
                   isvariable( newest_file ) ),
        contain => default:in_shell;
                   #or( isnewerthan( "$(newest_file)", "$(statefile)" ),
        #           not( fileexists( "$(statefile)" )) ),

  reports:
      "$(xccdf_files)";
      "Newest: $(newest_file)";
}

bundle agent inventory_report
{
  vars:
      "report_dat" string => "$(scc:inventory_parse.statefile)";

      # The Short Names are unique in a report, so we can parse with data_readstringarray having the result indexed by short name.
      "d_report_dat"
        data => data_readstringarray( "$(report_dat)",
                                      "",
                                      "\s+",
                                      "inf",
                                      "inf"),
        if => fileexists( "$(report_dat)" );

      "i" slist => getindices( d_report_dat );

      "results" slist => { "fail", "notapplicable", "notchecked", "pass" };

      "$(results)[$(i)]"
        string => "$(i)",
        meta => { "inventory", "attribute_name=SCC $(results)" },
        if => strcmp( "$(results)", "$(d_report_dat[$(i)])" );
}
