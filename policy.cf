bundle agent scc
{
  methods:
    "scc:packages";
    "scc:schedule";
    "scc:inventory";
}
bundle agent __main__
{
      methods: "scc";
}

body file control
{
  namespace => "scc";
}

bundle agent packages
{
  packages:

      "spawarscc"
        policy => "present",
        action => default:policy( "warn" ),
        classes => default:results( "bundle", "package_spawarscc" );

    package_spawarscc_not_kept::
      # TODO Redact this, for testing
      # Install the package if it's found in an expected location
      "/vagrant/scc-5.9_rhel8_x86_64/scc-5.9.rhel8.x86_64.rpm"
        policy => "present",
        if => fileexists( "/vagrant/scc-5.9_rhel8_x86_64/scc-5.9.rhel8.x86_64.rpm" );

  reports:
    package_spawarscc_not_kept::
      "$(with)"
        with => concat( "spawarscc is not installed, please retreive and",
                        " install the version appropriate for your platform from",
                        " https://public.cyber.mil/stigs/scap/" );

    package_spawarscc_kept.(scc:DEBUG_packages)::
      "spawarscc is installed";

}

bundle agent schedule
{
  vars:
      "seed" string => "$(sys.fqhost)$(sys.key_digest)";

      # "hour_start" The first hour under which you would like scans to
      # automatically run. expected to be defined via Augments, no default value

      # "window_length" The number of hours beginning from hour_start during
      # which you would like scans to automatically run. expected to be defined
      # via Augments, no default value

      # This won't be defined if window_length is not defined because of skipped
      # promises that contain unresolved variables.
      "hour_offset"
        int => hash_to_int( "0", "$(window_length)", "$(seed)" );

      # If the selected hour is not specified and neither a starting time and
      # windows length are defined just pick an hour any time during the day.
      "hour_selected"
        int => hash_to_int( 1, 24, "$(seed)" ),
        if => and( not( isvariable( "scc:schedule.hour_selected" ) ),
                   not( isvariable( "scc:schedule.hour_start") ),
                   not( isvariable( "scc:schedule.window_length" ) ) );

      # If hour_selected has yet to be defined
      "hour_selected"
        string => format( "%02d", eval( "($(hour_start)+$(hour_offset))%24", math, infix) ),
        if => and( not( isvariable( "scc:schedule.hour_selected" ) ),
                   and(
                        isvariable( "scc:schedule.hour_start" ),
                        isvariable( "scc:schedule.window_length") ) );

      "minute_selected"
        int => hash_to_int( 1, 59, "$(seed)" ),
        if => not( isvariable( "scc:schedule.minute_selected" ) );

      "weekday_map"
        data => '{
  "0": "Sunday",
  "1": "Monday",
  "2": "Tuesday",
  "3": "Wednesday",
  "4": "Thursday",
  "5": "Friday",
  "6": "Saturday"
}';

      "weekday_selected"
        int => hash_to_int( 0, 6, "$(seed)" ),
        if => not( isvariable( "scc:schedule.weekday_selected" ) );

      "monthday_selected"
        string => "*",
        if => not( isvariable( "scc:schedule.monthday_selected" ) );

      "time_selected"
        string => concat(
                          "$(weekday_map[$(weekday_selected)]) ",
                          format( "%02d", "$(hour_selected)" ),
                          ":",
                          format( "%02d", "$(minute_selected)" ) ),
        meta =>  { "inventory", "attribute_name=SCC Scheduled Scan Time" };

      "output_dir"
        string => "/tmp/SCC-RESULT",
        if => not( isvariable( "output_dir" ) );

      "command" string => "/opt/scc/cscc --userDir $(output_dir)";

      "cron_entry"
        string => "$(minute_selected) $(hour_selected) $(monthday_selected) * $(weekday_selected) root $(command) >/dev/null 2>&1$(const.n)",
        meta => { "report" };

  files:
      "$(output_dir)/."
        create => "true",
        comment => "The output directory must exist or the scc tool will not scan.";

      "/etc/cron.d/security-scan"
        content => concat( "# CFEngine Managed$(const.n)",
                           "$(cron_entry)" ),
        perms => default:mog( "644", "root", "root" ); # Wth, mode 0700!?

      # [root@hub scc]# cf-agent -KI
      # info: Created directory '/tmp/SCC-RESULT/.', mode 0700
      # info: Updated file '/etc/cron.hourly/security-scan' with content '# CFEngine Managed
      # 0 15 * * * /opt/scc/cscc --userDir /tmp/SCC-RESULT >/dev/null 2>&1'
      # R: Newest: $(newest_file)
      # error: A method attempted to use a bundle 'inventory_read' that was apparently not defined
      # error: Fatal CFEngine error: Aborting due to missing bundle 'inventory_read'

  commands:

      # Scheduling an initial scan
      # To improve the out of the box experience and in order to avoid causing a
      # long agent run we use systemd-run to schedule a scan in the future.
      # This is done if the output dir seems to have been created since the host
      # booted AND if there is no inventory statefile yet generated.

    !scc:initial_scan_disabled.default:systemd::
      "systemd-run"
        arglist => {
                     "--collect", # Clean up the run history
                     "--on-active=1",
                     "--unit=initial-scc-scan",
                     "--description='Initial scc scan'",
                     "$(command)"
        },
        if => and(
                   # Only if the output dir is new since this boot (un-necessary ?)
                   # isnewerthan( "$(output_dir)", "/proc/1" ),
                   # Only if we don't have existing parsed inventory (un-necessary ?)
                   # not( fileexists( "$(scc:inventory_parse.statefile)") ),
                   # Only if the directory is empty (finding . and ..)
                   not( isgreaterthan( length( lsdir( "$(output_dir)", "", false )), "2"))
                   ),
        comment => concat( "In order to get information back quickly, we use",
                           " systemd-run to schedule a one time job to avoid",
                           " creating a long agent run." ),
        contain => default:in_shell;
}

bundle agent inventory
{
  methods:
      "inventory_parse";
      "inventory_report";
}
bundle agent inventory_parse
{
  vars:
      "xccdf_files" slist => findfiles( "$(scc:schedule.output_dir)/**/*XCCDF-Results*.xml" );
      "xccdf_file_mtime[$(xccdf_files)]"
        string => filestat( $(xccdf_files), "mtime" );

      "statefile" string => "$(sys.statedir)/scc-scan-result-inventory.txt";

      # The file with the largest mtime is the newest
      "newest_time" string => max( getvalues( "xccdf_file_mtime" ), int );
      "newest_file" string => "$(xccdf_files)", if => strcmp( "$(xccdf_file_mtime[$(xccdf_files)])", "$(newest_time)" );

      "filename_extract"
        data => data_regextract( ".*SCC-(?<scc_version>\d+\.\d+)_(?<scan_YYYY>\d+)-(?<scan_MM>\d+)-(?<scan_DD>\d+)_(?<scan_hh>\d\d)(?<scan_mm>\d\d)(?<scan_ss>\d\d)_XCCDF-Results_(?<scan_ruleset>.*)\.xml",
                                 basename( "$(newest_file)" ) );
      # {
      #   "0": "HUB_SCC-5.9_2024-04-11_172103_XCCDF-Results_RHEL_8_STIG-1.12.8.xml",
      #   "scan_DD": "11",
      #   "scan_MM": "04",
      #   "scan_YYYY": "2024",
      #   "scan_hh": "17",
      #   "scan_mm": "21",
      #   "scan_ruleset": "RHEL_8_STIG-1.12.8",
      #   "scan_ss": "03",
      #   "scc_version": "5.9"
      # }
      "inventory_ruleset"
        string => "$(filename_extract[scan_ruleset])",
        if => isvariable( "filename_extract[scan_ruleset]" ),
        meta => { "inventory", "attribute_name=SCC Ruleset" };

      "inventory_report_date"
        string => "$(filename_extract[scan_YYYY])-$(filename_extract[scan_MM])-$(filename_extract[scan_DD])",
        if => and( isvariable( "filename_extract[scan_YYYY]" ),
                   isvariable( "filename_extract[scan_MM]" ),
                   isvariable( "filename_extract[scan_DD]" ) ),
        meta => { "inventory", "attribute_name=SCC Report Date" };

      "inventory_report_scc_version"
        string => "$(filename_extract[scc_version])",
        if => isvariable( "filename_extract[scc_version]" ),
        meta => { "inventory", "attribute_name=SCC Report Version" };

  commands:
      "/var/cfengine/bin/cfengine-selected-python $(this.promise_dirname)/tools/parseXML.py $(newest_file) --parse-findings > $(statefile)"
        if => and(
                   isvariable( newest_file ) ),
        contain => default:in_shell;
                   #or( isnewerthan( "$(newest_file)", "$(statefile)" ),
        #           not( fileexists( "$(statefile)" )) ),

  reports:
      "$(xccdf_files)";
      "Newest: $(newest_file)";
}

bundle agent inventory_report
{
  vars:
      "report_dat" string => "$(scc:inventory_parse.statefile)";

      # The Short Names are unique in a report, so we can parse with data_readstringarray having the result indexed by short name.
      "d_report_dat"
        data => data_readstringarray( "$(report_dat)",
                                      "",
                                      "\s+",
                                      "inf",
                                      "inf"),
        if => fileexists( "$(report_dat)" );

      "i" slist => getindices( d_report_dat );

      "results" slist => { "fail", "notapplicable", "notchecked", "pass" };

      "$(results)[$(i)]"
        string => "$(i)",
        meta => { "inventory", "attribute_name=SCC $(results)" },
        if => strcmp( "$(results)", "$(d_report_dat[$(i)])" );

      "count_results_$(results)"
        int => length( getindices( "$(results)" ) );

      "pass_fail_pct"
        string => format( "%0.2f", "$(with)" ),
        with => eval( "$(count_results_pass)/($(count_results_pass)+$(count_results_fail))*100", "math", "infix"),
        if => regcmp( "\d+\.*\d+", "$(with)" ),
        meta => { "inventory", "attribute_name=SCC % pass of checked" },
        comment => "This helps us easily identify the percentage of passing checks from those evaluated";

      # Stubbed out, this is really handy information, but it's fugly
      # "url_$(results)[$(i)]"
      #   string => "https://ato-pathways.com/search?q=$(i)&ifl=true",
      #   meta => { "inventory", "attribute_name=SCC $(results) URLs" },
      #   if => strcmp( "$(results)", "$(d_report_dat[$(i)])" );

  classes:

      # scc:compliance_checks_enabled must be /reported/ to the hub in order for
      # the related compliance module report to target checks. We define and
      # report that by default for plausibly supported platforms unless it's
      # explicitly disabled.

      !scc:compliance_checks_disabled::
        "compliance_checks_enabled"
          or => {
                  # each line maps to a single zip artifact used for all platforms on that line
                  # And, since we are in a namespace, we need to explicitly look for these in the default namespace
                  "default:redhat_pure.default:redhat_7.default:x86_64",  "default:oracle_7.default:x86_64",  "default:suse_12.default:x86_64",  "default:suse_15.default:x86_64",
                  "default:redhat_pure.default:redhat_7.default:aarch64", "default:oracle_7.default:aarch64", "default:suse_12.default:aarch64", "default:suse_15.default:aarch64",
                  "default:redhat_pure.default:redhat_8.default:x86_64",  "default:oracle_8.default:x86_64",
                  "default:redhat_pure.default:redhat_9.default:x86_64",  "default:oracle_9.default:x86_64",
                  "(default:ubuntu_18|default:ubuntu_20).default:x86_64",
                  "(default:ubuntu_20).default:aarch64",
                  "(default:ubuntu_22).default:x86_64",
          },
        meta => { "report" },
        scope => "namespace",
        comment => concat ("If this class is not reported compliance report",
                           " checks in Mission Portal will not be done." );
}
